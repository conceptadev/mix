"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireWildcard(require("react"));

var _clsx = _interopRequireDefault(require("clsx"));

var _Translate = _interopRequireDefault(require("@docusaurus/Translate"));

var _SearchBar = _interopRequireDefault(require("@theme/SearchBar"));

var _Toggle = _interopRequireDefault(require("@theme/Toggle"));

var _useThemeContext = _interopRequireDefault(require("@theme/hooks/useThemeContext"));

var _themeCommon = require("@docusaurus/theme-common");

var _useHideableNavbar = _interopRequireDefault(require("@theme/hooks/useHideableNavbar"));

var _useLockBodyScroll = _interopRequireDefault(require("@theme/hooks/useLockBodyScroll"));

var _useWindowSize = _interopRequireDefault(require("@theme/hooks/useWindowSize"));

var _useDocs = require("@theme/hooks/useDocs");

var _NavbarItem = _interopRequireDefault(require("@theme/NavbarItem"));

var _Logo = _interopRequireDefault(require("@theme/Logo"));

var _IconMenu = _interopRequireDefault(require("@theme/IconMenu"));

var _IconCloseThin = _interopRequireDefault(require("@theme/IconCloseThin"));

var _stylesModule = _interopRequireDefault(require("./styles.module.css"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
// retrocompatible with v1
const DefaultNavItemPosition = 'right';

function useNavbarItems() {
  // TODO temporary casting until ThemeConfig type is improved
  return (0, _themeCommon.useThemeConfig)().navbar.items;
} // If split links by left/right
// if position is unspecified, fallback to right (as v1)


function splitNavItemsByPosition(items) {
  const leftItems = items.filter(item => {
    var _item$position;

    return ((_item$position = item.position) !== null && _item$position !== void 0 ? _item$position : DefaultNavItemPosition) === 'left';
  });
  const rightItems = items.filter(item => {
    var _item$position2;

    return ((_item$position2 = item.position) !== null && _item$position2 !== void 0 ? _item$position2 : DefaultNavItemPosition) === 'right';
  });
  return {
    leftItems,
    rightItems
  };
}

function useMobileSidebar() {
  const windowSize = (0, _useWindowSize.default)(); // Mobile sidebar not visible on hydration: can avoid SSR rendering

  const shouldRender = windowSize === 'mobile'; // || windowSize === 'ssr';

  const [shown, setShown] = (0, _react.useState)(false); // Close mobile sidebar on navigation pop
  // Most likely firing when using the Android back button (but not only)

  (0, _themeCommon.useHistoryPopHandler)(() => {
    if (shown) {
      setShown(false); // Should we prevent the navigation here?
      // See https://github.com/facebook/docusaurus/pull/5462#issuecomment-911699846
      // return false; // prevent pop navigation
    }

    return undefined;
  });
  const toggle = (0, _react.useCallback)(() => {
    setShown(s => !s);
  }, []);
  (0, _react.useEffect)(() => {
    if (windowSize === 'desktop') {
      setShown(false);
    }
  }, [windowSize]);
  return {
    shouldRender,
    toggle,
    shown
  };
}

function useColorModeToggle() {
  const {
    colorMode: {
      disableSwitch
    }
  } = (0, _themeCommon.useThemeConfig)();
  const {
    isDarkTheme,
    setLightTheme,
    setDarkTheme
  } = (0, _useThemeContext.default)();
  const toggle = (0, _react.useCallback)(e => e.target.checked ? setDarkTheme() : setLightTheme(), [setLightTheme, setDarkTheme]);
  return {
    isDarkTheme,
    toggle,
    disabled: disableSwitch
  };
}

function useSecondaryMenu({
  sidebarShown,
  toggleSidebar
}) {
  var _useMobileSecondaryMe;

  const content = (_useMobileSecondaryMe = (0, _themeCommon.useMobileSecondaryMenuRenderer)()) === null || _useMobileSecondaryMe === void 0 ? void 0 : _useMobileSecondaryMe({
    toggleSidebar
  });
  const previousContent = (0, _themeCommon.usePrevious)(content);
  const [shown, setShown] = (0, _react.useState)(() => {
    // /!\ content is set with useEffect,
    // so it's not available on mount anyway
    // "return !!content" => always returns false
    return false;
  }); // When content is become available for the first time (set in useEffect)
  // we set this content to be shown!

  (0, _react.useEffect)(() => {
    const contentBecameAvailable = content && !previousContent;

    if (contentBecameAvailable) {
      setShown(true);
    }
  }, [content, previousContent]);
  const hasContent = !!content; // On sidebar close, secondary menu is set to be shown on next re-opening
  // (if any secondary menu content available)

  (0, _react.useEffect)(() => {
    if (!hasContent) {
      setShown(false);
      return;
    }

    if (!sidebarShown) {
      setShown(true);
    }
  }, [sidebarShown, hasContent]);
  const hide = (0, _react.useCallback)(() => {
    setShown(false);
  }, []);
  return {
    shown,
    hide,
    content
  };
}

function NavbarMobileSidebar({
  sidebarShown,
  toggleSidebar
}) {
  (0, _useLockBodyScroll.default)(sidebarShown);
  const items = useNavbarItems();
  const colorModeToggle = useColorModeToggle();
  const secondaryMenu = useSecondaryMenu({
    sidebarShown,
    toggleSidebar
  });
  return <div className="navbar-sidebar">
      <div className="navbar-sidebar__brand">
        <_Logo.default className="navbar__brand" imageClassName="navbar__logo" titleClassName="navbar__title" />
        {!colorModeToggle.disabled && <_Toggle.default className={_stylesModule.default.navbarSidebarToggle} checked={colorModeToggle.isDarkTheme} onChange={colorModeToggle.toggle} />}
        <button type="button" className="clean-btn navbar-sidebar__close" onClick={toggleSidebar}>
          <_IconCloseThin.default width={20} height={20} className={_stylesModule.default.navbarSidebarCloseSvg} />
        </button>
      </div>

      <div className={(0, _clsx.default)('navbar-sidebar__items', {
      'navbar-sidebar__items--show-secondary': secondaryMenu.shown
    })}>
        <div className="navbar-sidebar__item menu">
          <ul className="menu__list">
            {items.map((item, i) => <_NavbarItem.default mobile {...item} onClick={toggleSidebar} key={i} />)}
          </ul>
        </div>

        <div className="navbar-sidebar__item menu">
          {items.length > 0 && <button type="button" className="clean-btn navbar-sidebar__back" onClick={secondaryMenu.hide}>
              <_Translate.default id="theme.navbar.mobileSidebarSecondaryMenu.backButtonLabel" description="The label of the back button to return to main menu, inside the mobile navbar sidebar secondary menu (notably used to display the docs sidebar)">
                ‚Üê Back to main menu
              </_Translate.default>
            </button>}
          {secondaryMenu.content}
        </div>
      </div>
    </div>;
}

function Navbar() {
  const {
    navbar: {
      hideOnScroll,
      style
    }
  } = (0, _themeCommon.useThemeConfig)();
  const mobileSidebar = useMobileSidebar();
  const colorModeToggle = useColorModeToggle();
  const activeDocPlugin = (0, _useDocs.useActivePlugin)();
  const {
    navbarRef,
    isNavbarVisible
  } = (0, _useHideableNavbar.default)(hideOnScroll);
  const items = useNavbarItems();
  const hasSearchNavbarItem = items.some(item => item.type === 'search');
  const {
    leftItems,
    rightItems
  } = splitNavItemsByPosition(items);
  return <nav ref={navbarRef} className={(0, _clsx.default)('navbar', 'navbar--fixed-top', {
    'navbar--dark': style === 'dark',
    'navbar--primary': style === 'primary',
    'navbar-sidebar--show': mobileSidebar.shown,
    [_stylesModule.default.navbarHideable]: hideOnScroll,
    [_stylesModule.default.navbarHidden]: hideOnScroll && !isNavbarVisible
  })}>
      <div className="navbar__inner">
        <div className="navbar__items">
          {((items === null || items === void 0 ? void 0 : items.length) > 0 || activeDocPlugin) && <button aria-label="Navigation bar toggle" className="navbar__toggle clean-btn" type="button" tabIndex={0} onClick={mobileSidebar.toggle} onKeyDown={mobileSidebar.toggle}>
              <_IconMenu.default />
            </button>}
          <_Logo.default className="navbar__brand" imageClassName="navbar__logo" titleClassName="navbar__title" />
          {leftItems.map((item, i) => <_NavbarItem.default {...item} key={i} />)}
        </div>
        <div className="navbar__items navbar__items--right">
          {rightItems.map((item, i) => <_NavbarItem.default {...item} key={i} />)}
          {!colorModeToggle.disabled && <_Toggle.default className={_stylesModule.default.toggle} checked={colorModeToggle.isDarkTheme} onChange={colorModeToggle.toggle} />}
          {!hasSearchNavbarItem && <_SearchBar.default />}
        </div>
      </div>

      <div role="presentation" className="navbar-sidebar__backdrop" onClick={mobileSidebar.toggle} />

      {mobileSidebar.shouldRender && <NavbarMobileSidebar sidebarShown={mobileSidebar.shown} toggleSidebar={mobileSidebar.toggle} />}
    </nav>;
}

var _default = Navbar;
exports.default = _default;