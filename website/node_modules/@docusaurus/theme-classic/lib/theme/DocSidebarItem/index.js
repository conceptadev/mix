"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = DocSidebarItem;
exports.DocSidebarItems = void 0;

var _react = _interopRequireWildcard(require("react"));

var _clsx = _interopRequireDefault(require("clsx"));

var _themeCommon = require("@docusaurus/theme-common");

var _Link = _interopRequireDefault(require("@docusaurus/Link"));

var _isInternalUrl = _interopRequireDefault(require("@docusaurus/isInternalUrl"));

var _IconExternalLink = _interopRequireDefault(require("@theme/IconExternalLink"));

var _stylesModule = _interopRequireDefault(require("./styles.module.css"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
const isActiveSidebarItem = (item, activePath) => {
  if (item.type === 'link') {
    return (0, _themeCommon.isSamePath)(item.href, activePath);
  }

  if (item.type === 'category') {
    return item.items.some(subItem => isActiveSidebarItem(subItem, activePath));
  }

  return false;
}; // Optimize sidebar at each "level"
// TODO this item should probably not receive the "activePath" props
// TODO this triggers whole sidebar re-renders on navigation


const DocSidebarItems = (0, _react.memo)(function DocSidebarItems({
  items,
  ...props
}) {
  return <>
      {items.map((item, index) => <DocSidebarItem key={index} // sidebar is static, the index does not change
    item={item} {...props} />)}
    </>;
});
exports.DocSidebarItems = DocSidebarItems;

function DocSidebarItem({
  item,
  ...props
}) {
  switch (item.type) {
    case 'category':
      if (item.items.length === 0) {
        return null;
      }

      return <DocSidebarItemCategory item={item} {...props} />;

    case 'link':
    default:
      return <DocSidebarItemLink item={item} {...props} />;
  }
} // If we navigate to a category and it becomes active, it should automatically expand itself


function useAutoExpandActiveCategory({
  isActive,
  collapsed,
  setCollapsed
}) {
  const wasActive = (0, _themeCommon.usePrevious)(isActive);
  (0, _react.useEffect)(() => {
    const justBecameActive = isActive && !wasActive;

    if (justBecameActive && collapsed) {
      setCollapsed(false);
    }
  }, [isActive, wasActive, collapsed]);
}

function DocSidebarItemCategory({
  item,
  onItemClick,
  activePath,
  ...props
}) {
  const {
    items,
    label,
    collapsible
  } = item;
  const isActive = isActiveSidebarItem(item, activePath);
  const {
    collapsed,
    setCollapsed,
    toggleCollapsed
  } = (0, _themeCommon.useCollapsible)({
    // active categories are always initialized as expanded
    // the default (item.collapsed) is only used for non-active categories
    initialState: () => {
      if (!collapsible) {
        return false;
      }

      return isActive ? false : item.collapsed;
    }
  });
  useAutoExpandActiveCategory({
    isActive,
    collapsed,
    setCollapsed
  });
  return <li className={(0, _clsx.default)(_themeCommon.ThemeClassNames.docs.docSidebarItemCategory, 'menu__list-item', {
    'menu__list-item--collapsed': collapsed
  })}>
      {
      /* eslint-disable-next-line jsx-a11y/anchor-is-valid */
    }
      <a className={(0, _clsx.default)('menu__link', {
      'menu__link--sublist': collapsible,
      'menu__link--active': collapsible && isActive,
      [_stylesModule.default.menuLinkText]: !collapsible
    })} onClick={collapsible ? e => {
      e.preventDefault();
      toggleCollapsed();
    } : undefined} href={collapsible ? '#' : undefined} {...props}>
        {label}
      </a>

      <_themeCommon.Collapsible lazy as="ul" className="menu__list" collapsed={collapsed}>
        <DocSidebarItems items={items} tabIndex={collapsed ? -1 : 0} onItemClick={onItemClick} activePath={activePath} />
      </_themeCommon.Collapsible>
    </li>;
}

function DocSidebarItemLink({
  item,
  onItemClick,
  activePath,
  ...props
}) {
  const {
    href,
    label
  } = item;
  const isActive = isActiveSidebarItem(item, activePath);
  return <li className={(0, _clsx.default)(_themeCommon.ThemeClassNames.docs.docSidebarItemLink, 'menu__list-item')} key={label}>
      <_Link.default className={(0, _clsx.default)('menu__link', {
      'menu__link--active': isActive
    })} aria-current={isActive ? 'page' : undefined} to={href} {...(0, _isInternalUrl.default)(href) && {
      onClick: onItemClick
    }} {...props}>
        {(0, _isInternalUrl.default)(href) ? label : <span>
            {label}
            <_IconExternalLink.default />
          </span>}
      </_Link.default>
    </li>;
}